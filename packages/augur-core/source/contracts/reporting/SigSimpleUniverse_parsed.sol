pragma solidity >=0.5.10;


import 'ROOT/reporting/ISimpleUniverse.sol';
import 'ROOT/libraries/math/SafeMathUint256.sol';
import 'ROOT/Cash.sol';
import 'ROOT/TestNetDaiVat.sol';
import 'ROOT/TestNetDaiPot.sol';
import 'ROOT/TestNetDaiJoin.sol';
import 'ROOT/Augur.sol';


/**
 * @title Universe
 * @notice A Universe encapsulates a whole instance of Augur. In the event of a fork in a Universe it will split into child Universes which each represent a different version of the truth with respect to how the forking market should resolve.
 */
contract SigSimpleUniverse is ISimpleUniverse {
    using SafeMathUint256 for uint256;
    
    
    uint public DAILYBLOCKRATE;

    Augur public augur;

    
    uint256 public totalBalance;
    Cash public cash;
    TestNetDaiVat public daiVat;
    TestNetDaiPot public daiPot;
    TestNetDaiJoin public daiJoin;

    uint256 constant public DAI_ONE = 10 ** 27;

    
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER

    // Original code:
    // signal DailySignal

    // Generated variables that represent the signal
	bytes32 private DailySignal_dataslot;//the data pointer is NULL
	uint private DailySignal_status;
    bytes32 private DailySignal_key;

    // Get the argument count
	function get_DailySignal_is_fix() public pure returns (uint is_fix) {
       return 2;
    }

    // Get the signal key
	function get_DailySignal_key() public view returns (bytes32 key) {
       return DailySignal_key;
    }

    // Get the data slot
    function get_DailySignal_dataslot() private view returns (bytes32 dataslot) {
       return DailySignal_dataslot;
    }

    // signal DailySignal construction
    // This should be called once in the contract construction.
    // This parser should automatically call it.
    function DailySignal() private {
        DailySignal_key = keccak256("DailySignal()");
		assembly {
			sstore(DailySignal_status_slot, createsig(0, sload(DailySignal_key_slot)))
			sstore(DailySignal_dataslot_slot, 0x0)
		}
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////


    
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // GENERATED BY SIGNALSLOT PARSER

    // Original Code:
    // handler Update {...}

    // Generated variables that represent the slot
    uint private Update_status;
    bytes32 private Update_key;

    // Get the signal key
	function get_Update_key() public view returns (bytes32 key) {
       return Update_key;
    }

    // Update construction
    // Should be called once in the contract construction
    function Update() private {
        Update_key = keccak256("Update_func()");
        assembly {
            sstore(Update_status_slot, createslot(0, 10, 30000, sload(Update_key_slot)))
        }
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////

    // Update code to be executed
    // The slot is converted to a function that will be called in slot transactions.
    function Update_func()  public  {
        uint DBR = DAILYBLOCKRATE;
        sweepInterest();
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // emitsig DailySignal().delay(DBR)

        // Get the data slot
		bytes32 this_emitsig_DailySignal_dataslot = get_DailySignal_dataslot();
        // Get the signal key
		bytes32 this_emitsig_DailySignal_key = get_DailySignal_key();
        // Use assembly to emit the signal and queue up slot transactions
		assembly {
			mstore(0x40, emitsig(this_emitsig_DailySignal_key, DBR, this_emitsig_DailySignal_dataslot, 2))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }

    function saveDaiInDSR(uint256 _amount) private returns (bool) {
        daiJoin.join(address(this), _amount);
        daiPot.drip();
        uint256 _sDaiAmount = _amount.mul(DAI_ONE) / daiPot.chi(); 
        daiPot.join(_sDaiAmount);
        return true;
    }

    function withdrawDaiFromDSR(uint256 _amount) private returns (bool) {
        daiPot.drip();
        uint256 _chi = daiPot.chi();
        uint256 _sDaiAmount = _amount.mul(DAI_ONE) / _chi; 
        if (_sDaiAmount.mul(_chi) < _amount.mul(DAI_ONE)) {
            _sDaiAmount += 1;
        }
        _sDaiAmount = _sDaiAmount.min(daiPot.pie(address(this))); 
        withdrawSDaiFromDSR(_sDaiAmount);
        return true;
    }

    function withdrawSDaiFromDSR(uint256 _sDaiAmount) private returns (bool) {
        daiPot.exit(_sDaiAmount);
        daiJoin.exit(address(this), daiVat.dai(address(this)).div(DAI_ONE));
        return true;
    }

    function deposit(address _sender, uint256 _amount, address _market) public returns (bool) {
        require(augur.isTrustedSender(msg.sender) || msg.sender == _sender);
        augur.trustedTransfer(cash, _sender, address(this), _amount);
        totalBalance = totalBalance.add(_amount);
        marketBalance[_market] = marketBalance[_market].add(_amount);
        saveDaiInDSR(_amount);
        return true;
    }

    function withdraw(address _recipient, uint256 _amount, address _market) public returns (bool) {
        if (_amount == 0) {
            return true;
        }
        require(augur.isTrustedSender(msg.sender) || augur.isKnownMarket(IMarket(msg.sender)));
        totalBalance = totalBalance.sub(_amount);
        marketBalance[_market] = marketBalance[_market].sub(_amount);
        withdrawDaiFromDSR(_amount);
        cash.transfer(_recipient, _amount);
        return true;
    }

    function sweepInterest() public returns (bool) {
        uint256 _extraCash = 0;
        daiPot.drip();
        withdrawSDaiFromDSR(daiPot.pie(address(this))); 
        saveDaiInDSR(totalBalance); 
        _extraCash = cash.balanceOf(address(this));
        
        assert(daiPot.pie(address(this)).mul(daiPot.chi()).add(daiVat.dai(address(this))) >= totalBalance.mul(DAI_ONE));
        cash.transfer(address(this), _extraCash);
        return true;
    }
    
    function setdailyblockrate(uint dailyblockrate) public returns (bool) {
        require(dailyblockrate >= 200, "daily block rate must be exceed 200");
        DAILYBLOCKRATE = dailyblockrate;
    }

    constructor(Augur _augur, uint dailyblockrate) public {
   DailySignal();
   Update();
        DAILYBLOCKRATE = dailyblockrate;
        augur = _augur;
        cash = Cash(augur.lookup("Cash"));
        daiVat = TestNetDaiVat(augur.lookup("DaiVat"));
        daiPot = TestNetDaiPot(augur.lookup("DaiPot"));
        daiJoin = TestNetDaiJoin(augur.lookup("DaiJoin"));
        daiVat.hope(address(daiPot));
        daiVat.hope(address(daiJoin));
        cash.approve(address(daiJoin), 2 ** 256 - 1);
        
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // Update.bind(this.DailySignal)

        // Convert to address
		address this_bindslot_address = address(this);
        // Get signal key from emitter contract
		bytes32 this_bindslot_DailySignal_key = keccak256("DailySignal()");
        // Get slot key from receiver contract
        bytes32 this_this_bindslot_Update_key = get_Update_key();
        // Use assembly to bind slot to signal
		assembly {
			mstore(0x40, bindslot(this_bindslot_address, this_bindslot_DailySignal_key, this_this_bindslot_Update_key))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

        
        uint DBR = DAILYBLOCKRATE;
        
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // GENERATED BY SIGNALSLOT PARSER

        // Original Code:
        // emitsig DailySignal().delay(DBR)

        // Get the data slot
		bytes32 this_emitsig_DailySignal_dataslot = get_DailySignal_dataslot();
        // Get the signal key
		bytes32 this_emitsig_DailySignal_key = get_DailySignal_key();
        // Use assembly to emit the signal and queue up slot transactions
		assembly {
			mstore(0x40, emitsig(this_emitsig_DailySignal_key, DBR, this_emitsig_DailySignal_dataslot, 2))
	    }
        //////////////////////////////////////////////////////////////////////////////////////////////////

    }

}
